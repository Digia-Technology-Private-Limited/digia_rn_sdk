# Digia React Native SDK

<!-- Local asset image -->

[![Banner](https://raw.githubusercontent.com/Digia-Technology-Private-Limited/digia_ui/main/docs/images/readme_header.png)](https://www.digia.tech)

[![React Native](https://img.shields.io/badge/React%20Native-0.60+-blue.svg)](https://reactnative.dev)
[![TypeScript](https://img.shields.io/badge/TypeScript-4.0+-blue.svg)](https://www.typescriptlang.org/)
[![License](https://img.shields.io/badge/license-MIT-green.svg)](LICENSE)
[![Documentation](https://img.shields.io/badge/docs-digia.tech-blue.svg)](https://docs.digia.tech)

**Digia UI SDK** is the React Native-based rendering engine for [Digia Studio](https://app.digia.tech), a low-code mobile application platform. Built on the Server-Driven UI (SDUI) architecture, this SDK dynamically renders native React Native components based on configurations received from the server, enabling real-time UI updates without requiring app releases or store approvals.

# üöÄ Overview

### What is Server-Driven UI?

Server-Driven UI (SDUI) is an architectural pattern where the server controls the presentation layer of your application by sending UI configurations that the client interprets and renders. This approach offers several key advantages:

- **üöÄ Instant Updates** - Deploy UI changes immediately without app store review cycles
- **üß™ A/B Testing** - Run experiments and personalize experiences without client-side release cycles
- **üîß Bug Fixes** - Fix UI issues in production without releasing a new app version
- **üì± Cross-Platform Consistency** - Ensure uniform experiences across Android, iOS, and Mobile Web from a single configuration

### The Digia Ecosystem

Digia UI SDK is part of the Digia Studio ecosystem, where:

1. **Digia Studio** - A visual low-code tool where users drag and drop widgets to create mobile applications
2. **Server Configurations** - The studio generates structured configurations describing UI layout, data bindings, and business logic
3. **Digia UI SDK** - This React Native SDK interprets the server configurations to render fully functional native mobile apps across Android, iOS, and Mobile Web platforms

### Key Features

- üé® **Server-Driven UI** - Render React Native components from server-side configurations
- üîÑ **Instant Updates** - Push UI and logic changes instantly without app store approvals
- üîó **Expression Binding** - Powerful data binding system for dynamic content
- üéØ **Pre-built Actions** - Navigation, state management, API calls, and more
- üì± **Native Performance** - Rendering handled directly by React Native components for optimal performance
- üß© **Custom Components** - Register your own components to extend functionality
- üåê **Multi-Platform** - Single codebase for Android, iOS, and Mobile Web

## üì¶ Installation

Add Digia UI SDK to your project:

```bash
npm install digia-rn-sdk

```

### Required Peer Dependencies

```bash
npm install react react-native @react-navigation/native axios react-native-inappbrowser-reborn
```

Run:

```bash
npm install

```

## üèÅ Getting Started

> **Note**: Digia UI SDK requires configurations generated by [Digia Studio](https://app.digia.tech). Please refer to the [Digia Studio documentation](https://docs.digia.tech) to create your first project.

### Initialization of DigiaUI SDK

DigiaUI SDK offers two initialization strategies to suit different application needs:

#### NetworkFirst Strategy

- **Prioritizes fresh content** - Always fetches the latest DSL configuration from the network first
- **Fast performance** - DSL is hosted on CDN with average load times under 100ms for large projects
- **Recommended for production** - Ensures users always see the most up-to-date UI
- **Best for** - Apps where having the latest content is critical
- **Timeout fallback** - Optionally set a timeout; if exceeded, falls back to cache or burned DSL config

#### CacheFirst Strategy

- **Instant startup** - Uses cached DSL configuration for immediate rendering
- **Fallback to network** - Fetches updates in the background for next session
- **Offline capable** - Works even without network connectivity
- **Best for** - Apps prioritizing fast startup times or offline functionality

### Implementation Options

DigiaUI SDK offers two implementation options for different needs.

#### Option 1: Using DigiaUIApp

Use this approach when DigiaUI needs to be initialized before rendering the first frame.

```tsx
import { DigiaUI, DigiaUIApp } from 'digia-rn-sdk';

void main() {
  const digiaUI = await DigiaUI.initialize({
    accessKey: 'YOUR_PROJECT_ACCESS_KEY',
    flavor: Flavors.release({
      initStrategy: { type: 'network-first', timeoutInMs: 2000 },
      appConfigPath: 'path/to/config.json',
      functionsPath: 'path/to/functions.json',
    }),
  });

  AppRegistry.registerComponent('MyApp', () => () => (
    <DigiaUIApp
      digiaUI={digiaUI}
    >
      <NavigationContainer>
        <Stack.Navigator>
          <Stack.Screen
            name="Home"
            component={DUIFactory.getInstance().createInitialPage()}
          />
        </Stack.Navigator>
      </NavigationContainer>
    </DigiaUIApp>
  ));
}
```

#### Option 2: Using DigiaUIAppBuilder

For advanced use cases where you need more granular control over the initialization process. You can choose whether or not to wait for DigiaUI to be ready. This is especially useful when your app starts with a few native React Native screens before transitioning to DigiaUI-powered screens.

```tsx
import { DigiaUIAppBuilder } from 'digia-rn-sdk';

export default function App() {
  return (
    <DigiaUIAppBuilder
      options={{
        accessKey: 'YOUR_PROJECT_ACCESS_KEY', // Your project access key
        flavor: Flavors.release({
          initStrategy: { type: 'network-first', timeoutInMs: 2000 },
          appConfigPath: 'path/to/config.json',
          functionsPath: 'path/to/functions.json',
        }), // Use release or debug flavor
      }}
      builder={(status) => {
        // Make sure to access DUIFactory only when SDK is ready
        if (status.isReady) {
          return (
            <NavigationContainer>
              <Stack.Navigator>
                <Stack.Screen
                  name="Home"
                  component={DUIFactory.getInstance().createInitialPage()}
                />
              </Stack.Navigator>
            </NavigationContainer>
          );
        }

        // Show loading indicator while initializing
        if (status.isLoading) {
          return (
            <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
              <ActivityIndicator size="large" />
              <Text style={{ marginTop: 16 }}>Loading latest content...</Text>
              {status.hasCache && (
                <TouchableOpacity onPress={() => status.useCachedVersion()}>
                  <Text style={{ color: 'blue', marginTop: 8 }}>Use Offline Version</Text>
                </TouchableOpacity>
              )}
            </View>
          );
        }

        // Show error UI if initialization fails
        // In practice, this scenario should never occur, but it's a good habit to provide a user-friendly fallback just in case.
        return (
          <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
            <Text style={{ fontSize: 24 }}>‚ö†Ô∏è</Text>
            <Text style={{ marginTop: 16 }}>Failed to load content</Text>
            <Text>Error: {status.error}</Text>
            {status.hasCache && (
              <TouchableOpacity onPress={() => status.useCachedVersion()}>
                <Text style={{ color: 'blue', marginTop: 8 }}>Use Cached Version</Text>
              </TouchableOpacity>
            )}
          </View>
        );
      }}
    />
  );
}
```
<!-- 
## üõ†Ô∏è Usage Patterns

Digia UI SDK supports two integration patterns:

### 1. Full App Mode

Build your whole application in Digia Studio and use the SDK to render it. If you're on any paid plan, you can also download the APK directly from Digia Studio.

```tsx
<NavigationContainer>
  <Stack.Navigator>
    <Stack.Screen
      name="Home"
      component={DUIFactory.getInstance().createInitialPage()}
    />
  </Stack.Navigator>
</NavigationContainer>
```

### 2. Hybrid Mode

Migrate pages incrementally by mixing native React Native screens with Digia UI pages:

```tsx
// Navigate to a Digia UI page from native React Native
navigation.navigate('ProductDetails', {
  pageId: 'product_details',
  args: {
    productId: product.id,
  },
});
```

## üìÑ Creating Pages

Pages are complete, full-screen UI definitions that include lifecycle hooks and built-in state management.
Learn more about Pages in the [official documentation](https://docs.digia.tech/building-ui/pages).

```tsx
// Create a page with arguments
const checkoutPage = DUIFactory.getInstance().createPage('checkout_page', {
  cartId: '12345',
  totalAmount: 99.99,
});

// Navigate to a page
navigation.navigate('Checkout', {
  pageId: 'checkout_page',
  args: {
    cartId: '12345',
    totalAmount: 99.99,
  },
});
```

## üß© Creating Components

Components are modular UI elements that you can reuse throughout your app. They come with built-in lifecycle hooks and support for state management.
Find more details about Components in the [official documentation](https://docs.digia.tech/building-ui/components).

```tsx
import { DUIFactory } from 'digia-rn-sdk';

function ProductListPage({ products }) {
  return (
    <ScrollView>
      {products.map((product) => (
        <DUIFactory.getInstance().createComponent
          key={product.id}
          componentId="product_list_item"
          props={{
            id: product.id,
            title: product.title,
            price: product.price,
            imageUrl: product.imageUrl,
            rating: product.rating,
            isOnSale: product.isOnSale,
            discount: product.discount,
            onTap: () => navigateToProduct(product),
            onAddToCart: () => addToCart(product),
          }}
        />
      ))}
    </ScrollView>
  );
}
```

## üóÇÔ∏è State Management

Digia UI provides a comprehensive state management system with four levels:

### 1. Global State (App State)

Shared across the entire app and can optionally persist between sessions. Global state provides bidirectional communication between your native React Native code and Digia UI pages, enabling seamless integration and real-time updates.

**Key Features:**

- **Bidirectional Access** - Read and write from both native React Native code and Digia UI
- **Reactive Updates** - UI automatically updates when state changes from any source
- **Real-time Updates** - Changes are immediately reflected across all Digia UI pages
- **Persistence** - Can optionally persist between app sessions

**Setting State from Native Code:**

```tsx
import { DUIAppState } from 'digia-rn-sdk';

// In your native React Native code
class CartManager {
  addToCart(product) {
    // Update your business logic
    this.cart.add(product);

    // Sync with Digia UI - these changes will be immediately reflected in all Digia UI pages
    DUIAppState.instance.setValue('cartCount', this.cart.length);
    DUIAppState.instance.setValue('cartTotal', this.cart.totalAmount);
    DUIAppState.instance.setValue('cartItems', this.cart.items.map(item => item.toJson()));
  }

  updateUserProfile(user) {
    // Update user data that Digia UI pages can access
    DUIAppState.instance.setValue('user', {
      id: user.id,
      name: user.name,
      email: user.email,
      avatar: user.avatarUrl,
      preferences: user.preferences.toJson(),
    });
  }
}
```

**Accessing State in Digia Studio:**

For instructions on accessing App State within Digia Studio, please refer to the documentation.

**Listening to State Changes in Native Code:**

Global state changes can be monitored through listeners, enabling reactive programming patterns:

```tsx
import { DUIAppState } from 'digia-rn-sdk';

function HomePage() {
  const [cartCount, setCartCount] = useState(0);

  useEffect(() => {
    // Listen to global state changes
    const unsubscribe = DUIAppState.instance.listen('cartCount', (value) => {
      setCartCount(value);
    });

    return unsubscribe; // Clean up on unmount
  }, []);

  return (
    <View>
      <Text>Cart: {cartCount} items</Text>
    </View>
  );
}
```

#### Best Practices for Global State:

- **Use meaningful keys** - Choose descriptive names like `user.profile` instead of `data1`
- **Structure complex data** - Use nested objects for related data
- **Minimize state size** - Only store what's necessary for UI updates
- **Handle null values** - Always provide fallbacks in expressions
- **Clean up on logout** - Clear sensitive data when user logs out
- **Use streams wisely** - Cancel subscriptions to prevent memory leaks

### 2. Page State

Scoped to individual pages and cleared when page is disposed. Every page needs its own state management for handling user interactions, form data, loading states, and temporary data that shouldn't persist beyond the page lifecycle.

**Key Features:**

- Automatically initialized when page is created
- Cleared when page is disposed or navigated away
- Isolated from other pages
- Perfect for form data, loading states, and temporary UI state

**Common Use Cases:**

- Form validation and data
- Loading and error states
- Selected items in lists
- Temporary filters and search queries
- Modal and dialog states

### 3. Component State

Local state for reusable components. Components are modular UI elements that can maintain their own state independently, making them truly reusable across different pages and contexts.

**Key Features:**

- Each component instance has its own isolated state
- State persists as long as the component is mounted
- Enables building complex, stateful reusable components
- Perfect for interactive widgets like toggles, accordions, and custom inputs

**Common Use Cases:**

- Expandable/collapsible sections
- Custom input components with validation
- Interactive cards with hover/selection states
- Reusable form fields with their own validation
- Toggle switches and checkboxes

### 4. State Container (Local State)

Widget-level state for UI interactions within a specific component tree. While individual UI components in Digia Studio don't have built-in state, the Local State (State Container) provides a way to manage state in a localized manner within a component subtree.

**Key Features:**

- Scoped to a specific component subtree
- Managed by State Container components
- Enables stateful behavior for otherwise stateless components
- Perfect for localized UI interactions and temporary state

**Common Use Cases:**

- Counter components and numeric inputs
- Show/hide toggles for UI elements
- Tab selection within a component group
- Temporary UI state that doesn't need to persist
- Interactive animations and transitions

**State Hierarchy and Scope:**

- **Global State** - Available everywhere in the app
- **Page State** - Available within the current page and its components
- **Component State** - Available within the specific component instance
- **Local State** - Available within the State Container component subtree

**Best Practices:**

- Use Global State for user authentication, app settings, and data that needs to persist
- Use Page State for form data, loading states, and page-specific temporary data
- Use Component State for reusable component behavior and isolated interactions
- Use Local State for simple UI interactions and temporary component-level state

## üé® Custom Component Registration

Extend Digia UI with your own custom components:

```tsx
import { DUIFactory, VirtualWidget } from 'digia-rn-sdk';

// Define your custom component
class CustomMapComponent extends React.Component {
  render() {
    const { latitude, longitude, zoom } = this.props;

    return (
      <MapView
        style={{ flex: 1 }}
        initialRegion={{
          latitude,
          longitude,
          latitudeDelta: 0.0922,
          longitudeDelta: 0.0421,
        }}
      />
    );
  }
}

// Register during initialization
DUIFactory.getInstance().registerWidget(
  'custom/map',
  (props) => new CustomMapComponent(props),
);
``` -->

<!-- For detailed custom component documentation, visit [docs.digia.tech](https://docs.digia.tech/custom-components). -->

## üìÑ License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## üÜò Support

- üìö [Documentation](https://docs.digia.tech)
- üí¨ [Community](https://discord.gg/szgbr63a)
- üêõ [Issue Tracker](https://github.com/RamSuthar-Digia/digia_rn_sdk/issues)
- üìß [Contact Support](mailto:admin@digia.tech)

---

Built with ‚ù§Ô∏è by the Digia team
